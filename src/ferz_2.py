# рекурсивное решение и самое быстрое, которое я смог придумать
# работает в худшем случае за O(n!)
# чтобы ферзи не били друг друга необходимо, чтобы как минимум ни одна клетка
# i и j не совпадали
# поэтому массив Mas будет содержать в каких клетках j стоил ферзь
# клетку i будет просто увеличивать рекурсией
n = int(input())
cnt = 0
M=[] # массив, который содержит на каких позиция были поставлены ферзи
Mas = [0 for i in range(n)] # массив, который показывает в какой клетке j ферзь

def g(n, k, a, b):
    global cnt
    if n == k:
        cnt += 1
    else:
        # пройдем по всем клеткам j
        for j in range(b, n):
            # если клетка занята нет смысла идти дальше
            if Mas[j] == 1:
                continue
            # если клетка j не занята, то клетка i обязательно свободна
            # следовательно чтобы проверить можем ли мы поставить ферзя остается
            # только проверить не будет ли его кто-нибудь бить по диагонали
            f = 0
            for x in range(len(M)):        
                if abs(M[x][0] - a) == abs(M[x][1] - j):
                    f = 1
                    break
            # если ферзя никто не бьёт, то ставим его и вызываем рекурсию
            # и помещаем координаты поставленного ферзя в массив M
            if f == 0:
                M.append([a, j])
                Mas[j] = 1
                g(n, k + 1, a + 1, 0)
                Mas[j] = 0
                M.pop()

g(n, 0, 0, 0)
print(cnt)