# решение с помощью перестановок
# оно работает дольше рекурсивного всегда за O(n!)
# работает дольше, потому что не ометает ненужные перестановки
# так как мы знаем, что координаты i и j ни у одного ферзя совпадать не должны
# мы можем сгенерировать долько перестановки по 1 строке
from itertools import *

# функция, которая проверяет не бьют ли ферзя по диагонали
def f(a, j, M):
    for x in range(len(M)):
        if abs(M[x][0] - a) == abs(M[x][1] - j):
            return 0
    return 1

n = int(input())
m = [i for i in range(n)]
ms = permutations(m, n)
cnt = 0

for i in ms:
    s = list(i)
    g = 1
    M = []
    # так как первого ферзя мы можем поставить в любой столбец первой строчки
    # поэтому начнём цикл с 1
    for j in range(1, n):
        M.append([j - 1, i[j - 1]])
        # проверим не будут ли бить ферзя j, ферзи, которые стоят ранее
        if f(j, i[j], M) == 0:
            g = 0
            break
    #если не бьют, то нам подходит эта перестановка
    if g:
        cnt += 1

print(cnt)